# SleekWP Documentation

## File and folder structure

### / (root)

Contains all WordPress templates for every page type like `front-page.php`, `search.php` etc. These files are mostly empty except for `get_template_part()` calls which include modules.

### acf/

Contains all Advanced Custom Fields definitions and flexible content module templates. These will be covered in a separate chapter.

### dist/

Dist contains files generated by Gulp. Never put anything in there manually, the dist/ folder isn't even included in the repo by default.

### inc/

Contains PHP functions or third party PHP libraries included by `functions.php`.

### languages/

Contains all mo/po files for the theme's supported languages. Optionally contains Sleek language overrides inside `languages/sleek/`.

### modules/

Contains all modules used on the site such as `latest-news.php` or `recent-comments.php` etc.

### node_modules/

Contains JS or CSS packages installed with NPM. Never include this folder in the repo.

### src/

Contains all CSS, JS and assets (SVG, PNG etc).

## Modules and Templates

WordPress uses the templates located in your theme root for every page type it displays. For example on the search results page the `search.php` template is used, and in the archive the `index.php` template is used.

These templates should be kept clean from PHP or HTML and ideally should only _include_ modules they need. This way modules can be moved around and re-used with ease.

Every module should contain just one root element and be responsible for one single part of the page - never more. Also, give your root element an ID corresponding to the module's filename. The ID can be used for unique styling if needed.

For example:

**search.php**

```php
<?php get_header() ?>

<main>

	<?php get_template_part('modules/search-header') ?>
	<?php get_template_part('modules/search-results') ?>
	<?php get_template_part('modules/pagination') ?>

</main>

<?php get_footer() ?>
```

**modules/search-header.php**

```php
<header id="search-header">

	<h1><?php printf(__('Search results for "%s"', 'my-textdomain'), get_search_query()) ?></h1>

	<p><?php printf(__('%s posts were found!', 'my-textdomain'), $wp_query->found_posts) ?></p>

</header>
```

**modules/search-results.php**

```php
<section id="search-results">

	<?php while (have_posts()) : the_post() ?>
		<article>

			<h2><?php the_title() ?></h2>

			<?php the_excerpt() ?>

			<a href="<?php the_permalink() ?>"><?php _e('Read more', 'my-textdomain') ?></a>

		</article>
	<?php endwhile ?>

</section>
```

Sleek contains templates and modules for all of WordPress' page types but more often than not you're going to want to override them. If that's the case, simply copy the file from `sleek/modules/*.php` to `my-theme/modules/*.php` and it'll be used instead.

## PHP libraries/functions

Sometimes it's necessary to override parts of WordPress, modify "the loop", alter the way a plugin works or just add a utility function that's specific to your theme.

While it's possible to put all such code directly inside `functions.php` it's better to keep each function/class/filter/action in its own file inside `inc/`.

For example:

**inc/sort-employees-by-name.php**

```php
<?php
add_filter('pre_get_posts', function ($query) {
	if (!is_admin() and $query->is_main_query()) {
		if (is_post_type_archive('employee') or is_tax('employee_category')) {
			$query->set('orderby', 'post_title');
			$query->set('order', 'ASC');
		}
	}
});
```

And then include your file from `functions.php`:

```php
<?php
require_once 'inc/sort-employees-by-name.php';

# More code here...
```

## The functions.php file

Sleek already comes with plenty of WordPress tweaks and utility functions aimed at speeding up common tasks such as registering custom post types, adding external script or CSS files and more. The `functions.php` is well documented and is probably the first file you're going to want to modify when starting with your new theme.

Here I'll explain each of its functions/sections from top to bottom.

### Enable search inside custom fields (including ACF)

`require_once get_template_directory() . '/inc/include-postmeta-in-search.php';`

Uncommenting this `require` will make the built-in WordPress search look inside custom fields as well as "`the_content`". This is helpful if you have a lot of content inside advanced custom fields and you want that content to be considered when the user searches the site.

This functionality is commented by default as it modifies the main query and adds additional `JOIN`s. If you don't need this functionality it's unnecessary to run the code.

### Register thumbnail sizes

This is nothing special just the standard WordPress way of registering your thumbnail sizes. Stick to the built-in thumbnail size names as much as possible since they will be created regardless.

### Actually, use WP's built in sizes as far as we can (cus they're gonna get created anyway on every upload)

Because WordPress automatically creates three thumbnail sizes and use them internally (in the admin, or by plugins) it's much better to simply modify their sizes and use them throughout your theme as much as possible;

```php
<?php
add_action('after_setup_theme', function () {
	update_option('thumbnail_size_w', 640);
	update_option('thumbnail_size_h', 480);
	update_option('thumbnail_crop', 1);
	update_option('medium_size_w', 1280);
	update_option('medium_size_h', 960);
	update_option('medium_crop', 1);
	update_option('large_size_w', 1920);
	update_option('large_size_h', 1080);
	update_option('large_crop', 1);
});
```

### Register custom post types and taxonomies

Sleek comes with a utility function for registering custom post types. Simply pass an array of post type slugs into the function and they'll be registered using WordPress' `register_post_type()`. Should you want to override Sleek's default config for the post type you can pass in an associative array instead;

```php
<?php
sleek_register_post_types([
	'office',
	'employee',
	'case',
	'guide' => ['hierarchical' => true]
], 'my-textdomain');
```

The last argument is your theme's textdomain. The registered post type's name and URL will be run through the `__()` function so that it can be translated using your theme's PO files.

The CPT's URL will be `url_name-of-post-type` so you'll want to translate that to something nicer;

**languages/sv_SE.po**

```
msgid "Office"
msgstr "Kontor"

msgid "url_office"
msgstr "kontor"
```

Remember to flush permalinks after you've made changes to URLs.

If you use WPML it's important _not to_ translate CPT slugs. In this case, _don't_ pass in a textdomain to `sleek_register_post_types()`. When no textdomain is supplied the URL will be the same as the name of the post type (and can later be translated inside the WPML admin).

Similarly to `sleek_register_post_types()` there's also a `sleek_register_taxonomies()` that takes an associative array of taxonomies and which post types they belong to. It's best practice (it's mandatory! :) to name taxonomies `the-name-of-the-post-type_category`. This way you'll namespace your taxonomies and ensure they never collide with another post type's taxonomy.

In rare cases you want a taxonomy shared between several CPTs, simply pass in multiple post type names if that's the case, and don't prefix the taxonomy name:

```php
<?php
sleek_register_taxonomies([
	'case_category' => ['case'],
	'country' => ['office', 'employee']
], 'my-textdomain');
```

By default WordPress will show all registered post types on the search results page. While WP's `register_post_type()` function provides a method of disabling a CPT from appearing in search, using it also disables the CPTs archive page (it's a bug https://core.trac.wordpress.org/ticket/20234). Instead you can use `sleek_set_cpt_in_search(['case', 'guide'])` to tell WP which post types you want to display on the SERP. Note that `post` and `page` are always displayed.

### Add meta data (title, description, image) to CPTs

Use this function to give post types an admin page where you can set a custom title, description and image (this is useful for prettying up your archive pages).

### Register CSS and JS (automatically adds dist/all.css and dist/all.js which are generated by $ gulp)

Use `sleek_register_assets()` to add both `all.css` and `all.js` to the site. These files are generated by gulp.

If you want to include more CSS or JS, simply pass the paths as an array to the function;

`sleek_register_assets(['https://fonts.googleapis.com/css?family=Lato:300,900'])`

### Register sidebars

Once again Sleek comes with a wrapper function for WordPress' `register_sidebar()`; `sleek_register_sidebars()`. Simply pass in an array of sidebar slugs and titles. You can optionally override Sleek's default config by passing in an associative array;

```php
<?php
sleek_register_sidebars([
	'aside' => [
		'name' => __('Aside', 'my-textdomain'),
		'before_title' => '<h3>',
		'after_title' => '</h3>'
	],
	'header' => __('Header', 'my-textdomain'),
	'footer' => __('Footer', 'my-textdomain')
]);
```

### Add more options to Appearance -> Customize -> Theme Options

Sleek provides a utility function for easily adding fields to WordPress' Customize screen. These fields are useful for storing configuration variables like Google Analytics ID, Google Maps API Key etc. Simply register the field you need:

```php
<?php
add_action('customize_register', function ($wpCustomize) {
	sleek_register_theme_options($wpCustomize, [
		'my_cool_field' => 'text'
	], 'my-textdomain');
});
```

And then use the field however you want; `$myCoolField = get_theme_mod('my_cool_field')`. Sleek has built-in handling of Google Analytics and Google Maps (as well as integration with ACF's Google Map field).

Using an ACF options page might make more sense in some cases however.

### Add more fields to users

It's not uncommon to want to add additional fields to users, the functions file contains the code needed to do so. There's nothing Sleek specific about this code, it's here simply so that one doesn't have to Google it every time.

### Give pages excerpts

Similarly to user fields, this is a common feature for most themes and is here for convenience.

### Set up for translation (put your mo/po-files in your-theme/languages/)

This code just adds your PO/MO files and textdomain. If you need to override some of Sleek's translations you can add an additional `languages/sleek/` folder and add your overrides there.

## Advanced Custom Fields

While it's possible to register ACF using the GUI in the admin, doing so provides zero version control and makes it a hassle to deploy changes to your ACFs.

It's much better to register all ACF's using PHP. Advanced Custom Fields even recommends doing so.

However, using ACF's method of registering fields is a little limiting in that registering a field also requires you to specify _where_ said field should be used. In other words, it's difficult to create a field and use it in several places like a repeater, flexible content, options page _and_ on a specific post type.

Sleek comes with three utility functions for making this a breeze.

### Registering your fields

First start by creating your field group definition by adding a file to the `acf/` folder with the same name as your field group. In this example I'll be creating a simple video field (**Note:** _always_ prefix your field names with your field group name to avoid collisions with other fields!);

```php
<?php
return [
	[
		'name' => 'video-title',
		'label' => __('Title', 'my-textdomain'),
		'instructions' => __('Enter a title to display above the video.', 'my-textdomain'),
		'type' => 'text'
	],
	[
		'name' => 'video-description',
		'label' => __('Description', 'my-textdomain'),
		'instructions' => __('Enter a description for the video.', 'my-textdomain'),
		'type' => 'wysiwyg'
	],
	[
		'name' => 'video-code',
		'label' => __('Video', 'my-textdomain'),
		'instructions' => __('Copy the YouTube/Vimeo URL and paste it here.', 'my-textdomain'),
		'type' => 'oembed'
	]
];
```

Comparing this with the way ACF creates a field by default you'll notice a few differences;

```php
acf_add_local_field_group(array (
	'key' => 'group-video',
	'title' => 'Video Group',
	'fields' => array (
		# Note that this list of arrays is the only thing we added to the sleek version
		array (
			'key' => 'video-title',
			'label' => 'Title',
			'name' => 'video-title',
			'type' => 'text'
		),
		array (
			'key' => 'video-description',
			'label' => 'Description',
			'name' => 'video-description',
			'type' => 'wysiwyf'
		),
		array (
			'key' => 'video-code',
			'label' => 'Description',
			'name' => 'video-code',
			'type' => 'oembed'
		)
	),
	'location' => array (
		array (
			array (
				'param' => 'post_type',
				'operator' => '==',
				'value' => 'post',
			),
		),
	)
));
```

As you can see, using the default ACF method for registering the field requires us to 1) specify a field group where our fields will be located and 2) specify a location where our field group will be shown. This prevents us from easily adding this group to several places at once.

Using the Sleek method we instead omit the group and location definitions, as well as all `key`s. This is because we will specify the group's location later on when using the field.

### Using your fields

Now say we want all our posts to have a video, we can simply do: `sleek_register_acf(['post' => ['video']])` (**Note:** you can just keep adding other fields to the array containing `'video'`). This will create a new group and add it to the `post` post type.

Now imagine you also want a video in the footer so we need to add it to an options page, simply use `sleek_register_acf_options(['theme-settings' => ['video']])`. This will create an options page with the name "Theme settings" (and slug `theme-settings`) and add a "Video" tab to it.

Finally, you can also create a flexible content field and add the video as a flexible content field group to it; `sleek_register_acf_modules(['page' => ['name-of-flexible-content-field' => ['video']]])`. This will create a flexible content field called "Name of flexible content field" on pages which allow you to add the `video` field. Again, just keep adding field names to the array to add more fields.

With this in place you should see all the fields in the admin (please make sure ACF Pro is activated if you don't see anything). To use your fields you simply use the normal ACF functions like `get_field()` or `the_field()` etc.

### Using flexible content fields

_However_, when it comes to flexible content fields, Sleek once again has a nice utility function for looping through the flexible content field and automatically include any templates associated with the field.

First, let's create a template for the video field, just add a folder and file to the `acf/` folder; `acf/video/default.php`. The `video` folder name needs to be exactly the same name as your `video.php` field definition filename. The template filename can be anything you want, and if more than one are added a dropdown will appear in the admin allowing the user to select from all available templates. This is useful when you want a field group/module to have several different appearances but always use the same data.

Here's what a default video template might look like:

```php
<section id="video">

	<?php if ($data['video-title'] or $data['video-description']) : ?>
		<header>

			<?php if ($data['video-title']) : ?>
				<h2><?php echo $data['video-title'] ?></h2>
			<?php endif ?>

			<?php echo $data['video-description'] ?>

		</header>
	<?php endif ?>

	<div class="video"><?php echo $data['video-code'] ?></div>

</section>
```

Now to loop through the flexible content field and automatically include all included module templates simply go: `sleek_acf_render_modules('name-of-flexible-content-field')`.

And that's it! Using ACF fields this way is much more flexible than what is built in to ACF, while still managing to stay less verbose in that you don't need to supply `key`s or `locations`.

## SRC/ (the frontend code)

There's not much to the `src/` folder other than to put your SASS in `sass/`, JavaScript in `js/` and whatever assets you might have in `assets/`. SVG files should go in `assets/svg/` for them to run through the optimization tasks in gulp.

Icons are downloaded from Fontello based on the `icons.json` file. Import that to Fontello, add or remove whatever icons you want and download a new `config.json` replacing the previous `icons.json` and gulp will generate a new icon font and CSS classes.

JS is run through Browserify so you can include node modules using `var $ = require('jquery');` and so on.

Happy coding!
